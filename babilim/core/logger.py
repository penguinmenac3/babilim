# AUTOGENERATED! DO NOT EDIT! File to edit: dev/core_logger.ipynb (unless otherwise specified).

__all__ = ['__log_file', '__checkpoint_path', '__last_progress', '__last_update', 'PYTHON_IGNORE_LIST',
           '__get_all_files', 'log_value', 'log_progress', 'log_image', 'close', 'setup_minimal', 'setup', 'LogResult',
           'LogCall']


# Cell
# MIT License
#
# Copyright (c) 2019 Michael Fuerst
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import datetime
import filecmp
import json
import os
import shutil
import time
from typing import Callable, List

import numpy as np

import matplotlib.pyplot as plt
import scipy.misc
from .config import Config
from babilim import info, warn, DEBUG_VERBOSITY, set_logfile

# Cell
__log_file = None
__checkpoint_path = None
__last_progress = 0
__last_update = time.time()

PYTHON_IGNORE_LIST = ["__pycache__", "*.pyc", ".ipynb_checkpoints", "checkpoints", "dist", "docs", "*.egg-info",
                      "tfrecords", "*.code-workspace", ".git"]


# Cell
def _format_time(t):
    hours, remainder = divmod(t, 3600)
    minutes, seconds = divmod(remainder, 60)
    return '%d:%02d:%02d' % (hours, minutes, seconds)


# Cell
def _ignore(candidate: str, forbidden_list: List[str]) -> bool:
    # Parse list to find simple placeholder notations
    start_list = []
    end_list = []
    for item in forbidden_list:
        if item.startswith("*"):
            end_list.append(item.replace("*", ""))
        if item.endswith("*"):
            start_list.append(item.replace("*", ""))
    # Test
    res = candidate in forbidden_list
    for item in start_list:
        res |= candidate.startswith(item)
    for item in end_list:
        res |= candidate.endswith(item)
    return res


# Cell
def __get_all_files(root: str, forbidden_list: List[str]) -> List[str]:
    all_files = []
    root_with_sep = root + os.sep
    for path, subdirs, files in os.walk(root):
        files = [x for x in files if not _ignore(x, forbidden_list)]
        subdirs[:] = [x for x in subdirs if not x.startswith(".") and not _ignore(x, forbidden_list)]
        for name in files:
            all_files.append(os.path.join(path, name).replace(root_with_sep, ""))
    return all_files


# Cell
def _get_loaded_files(root: str = None, forbidden_list: List[str] = PYTHON_IGNORE_LIST) -> List[str]:
    """
    Get a list of all files that correspond to loaded modules in the root folder.

    If root is None the current cwd is used.
    """
    if root is None:
        root = os.getcwd()

    cwd_files = __get_all_files(root, forbidden_list)
    # TODO filter out all files that are not loaded.

    return cwd_files


# Cell
def _get_backup_path(fname: str, outp_dir: str = None) -> str:
    assert outp_dir is not None

    return os.path.join(os.path.normpath(outp_dir), fname)


# Cell
def _copyfile(src: str, dst: str, follow_symlinks: bool = True, create_missing_dirs: bool = True) -> None:
    dst_dir = os.path.dirname(dst)
    if not os.path.exists(dst_dir):
        os.makedirs(dst_dir)

    shutil.copyfile(src, dst, follow_symlinks=follow_symlinks)


# Cell
def _write_log(*, obj: object) -> None:
    """
    Write a log to the logfile or console if none is available.
    Furthermore send it to the online server if it is connected.

    :param obj: The json serializable object to log.
    """
    global __log_file
    out_str = json.dumps(obj)
    if __log_file is None:
        warn("You should setup logger before using it. Call ailab.logger.setup(...).")
        warn(out_str)
    else:
        with open(__log_file, "a") as f:
            f.write(out_str + "\n")


# Cell
def log_value(*, name: str, value: object) -> None:
    """
    Log a value to the file or online server.
    :param name: The name of the value to be logged.
    :param value: The actual value. It can be anything that is json serializable.
    """
    date = {
        "timestamp": "{}".format(datetime.datetime.now()),
        "name": name,
        "value": value
    }
    _write_log(obj=date)


# Cell
def log_progress(goal: str, progress: float, score: float) -> None:
    """
    Update the progress value. Automatically also computes the ETA and updates it in the logs.
    :param goal: The current goal it tries to reach. ("training", "validating", "pause", "waiting", "done")
    :param progress: A value between 0 and 1 indicating the progress, where 1 means done. The value should grow monotonic.
    :param score: The score that the approach achieved.
    """
    global __last_progress
    global __last_update

    assert 0 <= progress <= 1, progress

    delta_t = time.time() - __last_update
    delta_p = max(progress - __last_progress, 1E-6)
    __last_update = time.time()
    __last_progress = progress
    eta = (1.0 - progress) / delta_p * delta_t
    if goal == "pause" or goal == "waiting":
        eta = 0

    date = {
        "timestamp": "{}".format(datetime.datetime.now()),
        "eta": _format_time(eta),
        "goal": str(goal),
        "score": int(score * 1000) / 1000,
        "progress": int(progress * 1000) / 1000
    }
    _write_log(obj=date)


# Cell
def _log_code(*, chkpt_path: str, forbidden_list: list = []) -> None:
    """
    Log the code of the current working directory into the src folder of your checkpoint path.

    :param chkpt_path: The checkpoint folder.
    :param forbidden_list: The list of the forbidden files.
    """
    outp_dir = os.path.join(chkpt_path, "src")
    forbidden_list.extend(PYTHON_IGNORE_LIST)

    loaded_files = _get_loaded_files(forbidden_list=forbidden_list)
    # Copy preparation code to output location and load the module.
    for f in loaded_files:
        f_backup = _get_backup_path(f, outp_dir=outp_dir)
        _copyfile(f, f_backup)


# Cell
def _is_code_log_up_to_date(*, chkpt_path: str, forbidden_list: list = []) -> bool:
    """
    Check if the code in the logs is up to date or needs updates.

    :param chkpt_path: The checkpoint folder.
    :param forbidden_list: The list of the forbidden files.
    :return: True if the files are up to date, False if not.
    """
    outp_dir = os.path.join(chkpt_path, "src")
    if not os.path.exists(outp_dir):
        return False
    forbidden_list.extend(PYTHON_IGNORE_LIST)
    loaded_files = _get_loaded_files(forbidden_list=forbidden_list)

    for f in loaded_files:
        f_backup = _get_backup_path(f, outp_dir=outp_dir)
        # Check if data is already up to date
        if not os.path.exists(f_backup) or not filecmp.cmp(f, f_backup):
            return False

    return True


# Cell
def log_image(*, name: str, data: np.ndarray = None) -> None:
    """
    Log an image.
    :param name: The name of the image.
    :param data: The data (optional) if none is provided it is assumed that a pyplot figure should be saved.
    """
    global __checkpoint_path
    if __checkpoint_path is None:
        warn("Cannot log images when logger is not setup. Call logger.setup first")
        return
    if data is None:
        plt.savefig(os.path.join(__checkpoint_path, "images", name + ".png"))
    else:
        scipy.misc.imsave(os.path.join(__checkpoint_path, "images", name + ".png"), data)


# Cell
def close(reason: str = None) -> None:
    """
    Close the logger for a given reason.

    If none is provided there is no final progress written. Provide a reason, if you do not manually set the final progress before.
    A training loop typically manually sets the progress, so you will not need a reason in that case.

    :param reason: The reason for the closing of the logger. It is recommended to use "done", "paused", "failed" as reason.
    """
    global __log_file
    global __checkpoint_path
    global __last_progress
    global __last_update
    if __log_file is None:
        raise RuntimeError("You must setup the logger before you can close it!")
    if reason is not None:
        log_progress(goal=reason, progress=1.0, score=0.0)

    __log_file = None
    __checkpoint_path = None
    __last_progress = 0
    __last_update = time.time()


# Cell
def setup_minimal(log_folder: str) -> None:
    """
    Setup the a simple logger (not suitable for training) but for data generation/preprocessing.

    Creates the log folder, a src folder inside the log folder where it copies the current working directory and creates a log.txt, for logging progress.

    :param log_folder: Folder where the logs should be created.
    """
    global __log_file
    if __log_file is not None:
        raise RuntimeError("You must not setup logger twice!")
    if not os.path.exists(log_folder):
        os.makedirs(log_folder)

    if not _is_code_log_up_to_date(chkpt_path=log_folder):
        _log_code(chkpt_path=log_folder)
    __log_file = os.path.join(log_folder, "log.txt")
    log_progress(goal="waiting", progress=0, score=0)
    set_logfile(os.path.join(log_folder, "print_log"), time_suffix=False)


# Cell
def setup(config: Config, continue_with_specific_checkpointpath: bool = False, continue_training: bool = False) -> str:
    """
    Setup the logger.
    This creates the folder structure required at the place specified in config.train.checkpoint_path.
    After creating the folder structure it backs up the code of the current working directory to the folder structure.

    :param config: The configuration that is used for this run.
    :param continue_with_specific_checkpointpath: When a specific checkpoint is used to continue a run, set this. This avoids creating a new folder if it is not required.
    :param continue_training: Same as specific checkpoint but the checkpoint is automatically selected to be the most recent. This avoids creating a new folder if it is not required.
    :return: The path to the checkpoint folder.
    """
    global __log_file
    global __checkpoint_path
    if __log_file is not None:
        raise RuntimeError("You must not setup logger twice!")
    time_stamp = datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d_%H.%M.%S')
    chkpt_path = config.train_checkpoint_path + "/" + time_stamp
    chkpt_path = chkpt_path + "_" + config.train_experiment_name

    if continue_with_specific_checkpointpath:
        chkpt_path = config.train_checkpoint_path + "/" + continue_with_specific_checkpointpath
        if DEBUG_VERBOSITY:
            info("Continue with checkpoint: {}".format(chkpt_path))
    elif continue_training:
        chkpts = sorted([name for name in os.listdir(config.train_checkpoint_path)])
        chkpt_path = config.train_checkpoint_path + "/" + chkpts[-1]
        if DEBUG_VERBOSITY:
            info("Latest found checkpoint: {}".format(chkpt_path))

    if not os.path.exists(os.path.join(chkpt_path, "train")):
        os.makedirs(os.path.join(chkpt_path, "train"))
    if not os.path.exists(os.path.join(chkpt_path, "val")):
        os.makedirs(os.path.join(chkpt_path, "val"))
    if not os.path.exists(os.path.join(chkpt_path, "checkpoints")):
        os.makedirs(os.path.join(chkpt_path, "checkpoints"))
    if not os.path.exists(os.path.join(chkpt_path, "images")):
        os.makedirs(os.path.join(chkpt_path, "images"))

    setup_minimal(log_folder=chkpt_path)
    __checkpoint_path = chkpt_path
    config.train_actual_checkpoint_path = chkpt_path
    return chkpt_path


# Cell
class LogResult(object):
    def __init__(self, *, name: str) -> None:
        """
        Annotation to log the result of a function.

        A simple example would be the primary loss the training pipeline.

        >>> @LogResult(name="loss")
        >>> def loss(y_true, y_preds):
        >>>     return 42
        42

        :param name: The name for the logged result.
        """
        self.name = name

    def __call__(self, f: Callable) -> Callable:
        def wrapped_f(*args, **kwargs):
            result = f(*args, **kwargs)
            log_value(name=self.name, value=result)
            return result

        return wrapped_f


# Cell
class LogCall(object):
    def __init__(self, *, name: str) -> None:
        """
        Annotation to log the number of times a function is called.

        The following example logs a variable step, which tracks how often the function step gets called.

        >>> @LogCall(name="step")
        >>> def step():
        >>>     # Fancy training code...
        >>>     return 42
        42

        :param name: The name of the logged function call counting.
        :param primary: If the logged result is the primary loss (it probably isn't)
        """
        self.name = name
        self.i = 0

    def __call__(self, f: Callable) -> Callable:
        def wrapped_f(*args, **kwargs):
            log_value(name=self.name, value=self.i)
            self.i += 1
            result = f(*args, **kwargs)
            return result

        return wrapped_f
